# MYSQL扫盲

## InnoDB的锁

> InnoDB支持行级锁和表级锁
>
> MyIsiam支持表级锁

### 1. 锁的类型

根据`范围`划分：表、行、页

根据`类别`划分：排他锁、共享锁、意向锁

排他锁和共享锁的执行粒度：表、行

意向锁的执行粒度：表

范围缩的执行粒度：行

### 2. 独占锁与共享锁

InnoDB加锁的粒度是行

- **排他锁**（写锁）：更新表中的某一行数据
- **共享锁**（读锁）：读取表中的某一行数据

共享锁与共享锁之间不互斥：允许并发读

共享锁与排他锁之间互斥：不允许并发读写

排他锁与排他锁之间互斥：不允许并发写

`对表进行DDL操作时，会在表这个粒度上加排他锁或者共享锁`

### 3. 意向锁

> 当一个事务想要对表加独占锁时，它会检查这张表中的某一行是否被其他事务加了独占锁。
>
> 因此这个事务在加锁前会首先遍历表中的每一行，只要有任意一行加了独占锁，就意味着这张表加了独占锁。
>
> 但这样的查询效率是在太低了，而意向锁就是为了解决这个锁定判断效率问题而产生的。

意向锁属于`表级别`的锁，分为**意向独占锁**和**意向共享锁**

- 事务要想给表中的某一行加上排他锁，必须先获得这张表的意向排他锁

- 事务要想给表中的某一行加上共享锁，必须先获得这张表的意向共享锁

有了这种意向锁之后，当事务想要给整张表加表排他锁时，不用遍历所有记录了。

只需要查看这张表有没有被其他事务加上意向排他锁或者意向共享锁，就能作出判断。

### 4. 范围锁

执行下述语句时，不止给数据库已有的数据加上了行锁，还加了范围锁(`对某个范围的数据加锁`)

~~~sql
select * from book_store where price < 5 for update
~~~

范围锁和行锁密切相关，是基于行的基准上。也可以令称为锁行的**三种算法**：

- Record Lock（行级锁）：单个行记录上的锁
- Gap Lock（间隙锁）：某个范围上的锁，不包括行记录本身
- Next-Key Lock（临键锁）： Record Lock + Gap Lock
- Insert Intesion （插入意向锁）：专门用于insert操作的锁，多事务对同一个范围、同一区间可以并发插入，插入意向锁之间不会相互阻塞，但会有间隙锁产生互斥

InnoDB行锁的实现依赖于`索引`，一旦没有使用到索引，那么行锁便会退化到表锁

1. 主键索引或唯一索引：行级锁
2. 普通索引：临键锁
3. 无索引：退化为表锁

范围锁的特点：

- **范围锁基于行锁**

- **加了范围锁之后，不仅不能修改这个范围已有的数据，也不能在这个范围内新增或修改任何数据(防止了幻读)**
- **范围锁只在RR（可重复读）这个隔离级别中有效**

关于间隙锁的加锁机制：



## 隔离级别

实现隔离级别的两个方向：

- 悲观锁
- 乐观锁

事务的四种隔离级别：

1. 未提交读：读取到其他事务未提交的修改
2. 已提交读：读取到其他事务已提交的修改
3. 可重复读：多次读取的内容不会有变化，但可能会读到新增的数据
4. 串行化：最强的隔离级别，对事务进行串行化执行

### 悲观锁

使用锁实现四种隔离级别：

1. 未提交读：读取的数据不需要加共享锁，不会与修改数据的排他锁互斥
2. 已提交读：对读取的数据加共享锁，读取语句执行完后释放
3. 可重复读：对读取的数据加共享锁，事务执行完毕后释放
4. 串行化：对整个`范围`加共享锁，事务执行完毕后释放

如果使用锁来实现四种隔离级别，那么不可避免会产生`死锁`

死锁：两个或多个事务相互争夺资源而造成相互等待的一种现象

为了避免产生死锁，mysql使用的是`无锁方案`来实现可重复读和已提交提，那就是MVCC

### 乐观锁

大体思路：每次提交时检查数据是否已经被其他事务修改了，若已经修改则重新执行事务

MVCC（多版本并发控制）是MySQL服务器实现隔离级别`已提交读`和`可重复读`的机制。

MVCC的实现机制依赖于ReadView和UndoLog 

## 事务日志

### 出现原因

现代的数据库都遵循两个策略和一个协议：

- `Steal Policy`：在事务提交前，允许内存页的数据刷回磁盘
  - 提高了数据库的I/O效率，因为等到最终提交事务时，要写入磁盘的数据量会小
  - **事务提交前，如果数据库崩溃的话，如何未提交的事务的修改已经刷回磁盘了，如何回滚？**
- `Unforce Policy`：在事务提交后，不会强迫内存页的数据刷回磁盘
  - 给了数据库更高的自由度，允许数据库开启一个后台线程将脏页刷回磁盘
  - **事务提交后，如果数据库系统崩溃的话，如果内存页中的数据还没刷回磁盘，如何恢复？**

要解决Steal Policy的问题，就必须有一样东西A记录未提交事务所作的修改，并且在刷回磁盘前就已经持久化了。 A：undo-log

要解决Unforce Policy的问题，就必须有一样东西B记录提交的事务所作的修改，并且在提交事务前就已经持久化了。B：redo-log

可以从上面日志的描述看到，要想redo-log进行恢复，或者undo-log进行回滚，这两个日志必须遵守`WAL（Write-Ahead Log）`协议:

- 在事务提交前，redo-log必须已经持久化到磁盘
- 在脏页刷盘前，undo-log必须已经持久化到磁盘

### 崩溃恢复

1. 分析阶段（analysis）：该阶段从最后一次检查点（check point）开始扫描日志，找出活跃的事务集合和脏页表
2. 重做阶段（redo）：从脏页表中找出最早的日志序列号（LSN），从该日志序列号开始对后面所有的日志进行持久化
3. 回滚阶段（undo）：活跃的事务集合中便是需要回滚的事务，根据undo-log的回滚链表对该事务的所有操作进行回滚

### 重做日志

物理日志，通常记录页所作的修改，当脏页还没写回磁盘，系统就崩溃了的话，可以使用redo log恢复，保证了Unforce Policy

### 回滚日志

逻辑日志，通常记录每行数据，当delete一条数据时，undo log会记录相应的insert操作，当update一条数据时，它会记录一条相反的update操作，可以使用undo-log进行回滚，保证了Steal Policy的执行

### 数据结构