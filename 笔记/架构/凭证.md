# 凭证

## 1. Cookie-Session

HTTP是一种无状态的协议，没有上下文的记忆能力。这种特性有悖于常见的网络场景 -----------> “认证授权”

系统总得需要获知用户身份才可能提供合适的服务吧，因此HTTP需要有一种手段，需要区分出发送请求的用户是谁

> 在分布式系统以前，这个问题已经有了较为同一的结论，即以Cookie-Session机制为代表的服务器端状态存储

1. 当客户端第一次登录服务器端时，服务器会创建session存储该用户的信息

2. 服务器端向登录的客户返回`set-cookie`指令

   ~~~http
   set-cookie: sessionid=icyfenix
   ~~~

3. 下次客户再次发起请求时，携带这条信息

   ~~~http
   cookie: sessionid=icyfenix
   ~~~

通过这种机制，服务器便能够分辨出请求来自那个用户

Session-Cookie在单体应用中是最合适的方案，但当需要水平扩展服务能力，进行分布式集群部署时就比较麻烦了。Session存储在服务器的内存中，设计成多节点时，只能选择一下三种方案之一（CAP）：

- 牺牲集群的**一致性**：通过负载均衡算法，根据用户的IP或Session来分配节点，将特定用户的所有请求都分配到其中某一个节点，每个节点都不重复的保存一部分用户的数据，如果这个节点崩溃，里面的用户状态也就丢失了
- 牺牲集群的**可用性**：各个节点间采用复制的Session，每个节点的Session变动都会发送到其他服务器。某个节点崩溃了不会中断某个用户的服务，但是同步的代价高昂，成本随着节点个数的增多而增大
- 牺牲集群的**分区容忍性**：普通的服务节点不再保留状态，而是将所有数据都存储到所有节点都能访问的数据节点。此时的问题是数据节点称为单点，一旦出现网络分区，所有数据都不可访问了。

只要在分布式系统中共享信息，CAP不可兼得

## 2. JWT

无论采用哪种方案，都无法解决Session的在分布式系统中的共享问题。

既然服务器无法共享数据，就尝试在客户端存储数据，但我们也需要明白客户端存储数据的弊端：

- 无法携带大量信息
- **信息会有泄露和篡改的风险** (JWT解决了第二个问题)

<img src="凭证.assets/1821058-2e28fe6c997a60c9.png" alt="img" style="zoom: 55%; float: left;" />

JWT是JSON结构存储的令牌，结构上分为三部分：

<img src="凭证.assets/xrvp4pjty8.png" alt="preload" style="zoom:87%;float:left" />

1. **Header** 令牌头

   ~~~json
   {
       "alg":"HS256"
       "typ":"JWT"
   }
   ~~~

   Header定义了**令牌的类型**和**签名的算法**，HS256是HMAC SHA256的缩写

   它与SHA256的区别是，HMAC哈希算法把密钥以**加盐**的方式和内容一起进行哈希摘要

   这部分的信息会使用`base64`算法加密(该算法可解密)，构成`jwt`的第一部分

2. **Payload** 负载

   ~~~json
   {
       "username":"icyfenix",
       "iss":"bilibli.com",
       "exp":"14323490234",
       ...
   }
   ~~~

   负载包含了**向服务器传递的信息**，完全可以用户自定义

   - 对于认证问题：至少包含能够告知服务器“这个用户是谁”的信息
   - 对于授权问题：至少包含能够告知服务器“这个用户拥有哪些权限”的信息

   除去用户自定的信息外，还推荐包含以下内容

   1. iss：签发人
   2. exp：令牌过期时间
   3. nbf：令牌生效时间
   4. iat：令牌签发时间
   5. jti：令牌编号
   6. sub：主题
   7. aud：令牌受众

   这部分的信息也会使用`base64`算法加密，构成`jwt`的第二部分

3. **Signature** 签名

   使用令牌头的哈希算法，通过特定的密钥(服务器保存)，对前两部分进行加密计算

   ~~~markdown
   signature = HMACSHA256(base64UrlEncode(header) + "." + base64UrlEncode(payload), secret)
   ~~~

   签名信息会构成`jwt`的第三部分
   
   之后将该`jwt`凭证设置在`set-cookie : authorization`返回给客户端

客户端再次访问时，需要携带token，后端对token进行验证：

- 对第二部分进行解密，检测令牌是否过期
- 对第一部分和第二部分进行解密，同时使用加盐的方式再次使用`HMACSHA256`加密计算签名
- 比较计算的签名是否与传过来的签名相同